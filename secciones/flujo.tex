%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Flujo de trabajo

\section{Flujo de trabajo y control de versiones}\label{flujo:flujo-de-trabajo}

\subsection{Metodología Kanban}\label{flujo:metodologia-kanban}
\subsubsection{El Tablero Kanban}\label{flujo:tablero-kanban}
Trello será la herramienta principal para mantener la coordinación del flujo de trabajo a través de un \textbf{Tablero Kanban}. Para el desarrollo del proyecto dividiremos el trabajo en tareas y las iremos incorporando a este tablero dentro de columnas que vienen a representar nuestros procesos de producción.

La idea es anotar cada tarea del proyecto en una tarjeta y agregarla a la columna de la izquierda. Mientras se trabaja en la tarea, su tarjeta va avanzando de izquierda a derecha hasta llegar a la última columna.  

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{imágenes/tablero01.png}
	\caption{Tablero Kanban en Trello.}
\end{figure}

\subsubsection{Límites de trabajo y columnas asociadas}\label{flujo:limites-de-trabajo}
Cada columna tiene asociado un límite máximo de tareas simultáneas (\lsc{WIP}) por lo que si el límite ha sido alcanzado no se podrán incorporar nuevas tareas a la columna hasta haber avanzado una de sus tarjetas a la columna siguiente. Este límite se puede ver en el número dentro de llaves [~].

Al mismo tiempo, cada columna tendrá una división vertical, dejando a la izquierda las tareas en proceso y a la derecha las tareas que ya han completado la etapa. El límite es compartido por ambas secciones, por lo que independiente de la sección en la que se encuentre la tarjeta, no puede haber más tarjetas que el límite establecido en la columna.

Lamentablemente la plataforma Trello no permite dividir una misma columna en dos secciones, por lo que se añadirá una enumeración al nombre de cada columna que se repetirá en los casos de columnas asociadas. Por ejemplo en la \autoref{flujo:figura-wip}, sumando las tareas de la columna “2. [5] Trabajando” y las de la columna “2. Terminadas” solo puede haber 5 tareas simultáneas por lo que no deberemos añadir una sexta.

\begin{figure}[h]
	\centering
	\caption{Límites de trabajo en Trello.}
	\label{flujo:figura-wip}
	\includegraphics[width=\textwidth]{imágenes/tablero02.png}
\end{figure}

Respetar los límites de cada columna, facilitará la distribución de trabajo en un modelo de entrega continua y nos permitirá tomar decisiones más acertadas y realistas al momento de la planificación.

\subsubsection{Descripción de columnas}\label{flujo:descripcion-de-columnas}
El funcionamiento de cada columna es bastante sencillo:
\begin{enumerate}
	\item \textbf{Columna Tareas:} Acá dejamos las tareas en sus tarjetas y las ordenamos según prioridad (arriba más urgentes). Solo se debería empezar a trabajar en la tarea superior. La prioridad de las tareas será determinada por el equipo.
	\item \textbf{Columna Desglose de tareas:} Es \textit{muy importante} que las tareas sean descompuestas en tareas sencillas para que no se demoren más de unos días en completarse. Las tareas que entran a esta columna se analizan y dividen en tareas acotadas.
	\item \textbf{Columna Desglosadas:} Aquí las tareas desglosadas esperan hasta que alguien se haga cargo de implementar el código y pasan a la siguiente columna.
	\item \textbf{Columna Trabajando:} Aquí el encargado se anota en la tarjeta y trabaja hasta completarla, pasándola a Terminadas. Una tarea se considerará completada solo cuando haya pasado todos los test correspondientes.
	\item \textbf{Columna Implementadas:} Acá quedan las tarjetas con tareas terminadas esperando revisión.
	\item \textbf{Columna En revisión:} Acá van las tareas que se estén revisando. Si tienen problemas o bugs pequeños se resuelven aquí mismo, si tuviera bugs o un problema más grande podría volver a analizarse el desglose con alta prioridad.
	\item \textbf{Columna Hecho:} Aquí van las tareas terminadas. Se eliminan al hacer el merge de un conjunto de features completo a develop (cuando sube la versión).
\end{enumerate}

\subsubsection{Flexibilidad}\label{flujo:flexibilidad}
Esta es una herramienta que permite tener visualizadas las distintas áreas del proyecto, identificar cuellos de botella y contribuir a la gestión mediante límites de trabajo; no obstante, no debe olvidarse que es solo una guía. Si algo del sistema necesita cambiarse porque va contra el flujo de trabajo, se debe ajustar rápidamente.

\subsubsection{Nombres de Tarjetas}\label{flujo:nombres-de-tarjetas}
Los nombres de las tareas se deben corresponder con la tarea o funcionalidad a implementar y a su rama asociada en \lsc{GIT}. Más detalles en el apartado \nameref{organizacion:nombres-de-ramas}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\pagebreak
\subsection{Repositorio}\label{flujo:repositorio}
El repositorio \lsc{GIT} de Bakumapu se encuentra alojado en la siguiente dirección: \url{https://github.com/polirritmico/Bakumapu}.

La contribución de código será organizada a través del modelo de ramas de función (feature branching) adaptada a un sistema de TDD de entrega continua (más información en el apartado \nameref{principios:principios-de-diseno}).

\subsubsection{Modelo de Ramas de función}\label{flujo:modelo-de-ramas}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{imágenes/git.png}
	\caption{Ramas en \lsc{GIT}.}
\end{figure}

\Needspace{3\baselineskip}
\noindent\textbf{Ramas principales.}\label{flujo:ramas-principales}

\noindent Bakumapu contará con 3 ramas principales, \textbf{develop}, \textbf{main} y \textbf{release}:

\begin{enumerate}
	\renewcommand{\labelenumi}{\alph{enumi}.}
	\item \textbf{develop:} Esta rama contará siempre con las últimas funciones implementadas. Es la rama principal del desarrollo ya que para trabajar cada feature, se creará una rama a partir de \textbf{develop}. A medida que se avance esa implementación continuamente se harán merges de vuelta a \textbf{develop} (al menos uno al día)\footnote{Es muy importante este punto porque el tiempo que el código de la rama permanezca fuera de develop puede generar bugs desconocidos al estar aislado de los commit de otras ramas.}. De esta forma se pretende que esté siempre disponible el código completo para no perder la referencia global del proyecto. 
	
	\item \textbf{main:} En esta rama se tratará de mantener el código lo más estable posible. Representa la última entrega del desarrollo y por lo tanto se creará a partir de \textbf{develop} cuando el código haya completado el conjunto de features de cada etapa de implementación del proyecto. Los testers trabajarán en base a esta rama. 
	
	\item \textbf{release:} Se creará a partir \textbf{main} una vez que esta haya sido extensamente probada y depurada. Esta rama será la que pasará el código a producción por eso debe ser la más robusta (por ejemplo deploys automáticos a todas las copias instaladas y conectadas a internet).
\end{enumerate}

\paragraph{Ramas de implementación}\label{pg:ramas-de-implementacion}
\begin{enumerate}
	\renewcommand{\labelenumi}{\alph{enumi}.}
	\item \textbf{Ramas de features:} Debe crearse una para cada funcionalidad que se quiera implementar a partir del estado actual de la rama \textbf{develop}. El nombre de la rama debe comenzar con “\textbf{ft-}” y corresponderse con el de su tarjeta asociada en el tablero (apartado \nameref{flujo:nombres-de-tarjetas}). La idea es desarrollar test que permitan verificar el funcionamiento de la feature y que deben ser superados antes de dar por concluido el trabajo en la rama. De esta forma se intentará hacer continuos merges hacia \textbf{develop} con la certeza de haber superado los test.
	
	\item \textbf{Ramas de bugs:} Debe crearse una por cada bug encontrado. Dependiendo del bug la rama será creada a partir de \textbf{main}, \textbf{develop} o \textbf{release}. El merge del fix deberá ser hacia \textbf{develop} y si corresponde también a \textbf{release}. El nombre de la rama debe comenzar con “\textbf{bug-}” y corresponderse con el de su tarjeta asociada en el tablero (apartado \nameref{organizacion:nombres-de-ramas}).
\end{enumerate}

Para una información más detallada sobre el funcionamiento de \lsc{GIT} bajo el modelo de ramas de función ver el \href{https://www.atlassian.com/es/git/tutorials/comparing-workflows/feature-branch-workflow}{siguiente enlace} (no olvidar los matices con respecto al trabajo bajo TDD en el apartado \nameref{principios:vision-general-desarrollo}).

\subsubsection{Versionado y nombres semánticos}\label{flujo:versionado-y-nombres}
Los nombres de las versiones seguirán la nomenclatura de versionado semántico, en este caso \textbf{Bakumapu\_vX.Y.Z} donde cada número representa:
\begin{itemize}[label=-]
	\item \textbf{X:} La versión principal. 0 alfa, 1 release. Si hay cambios no compatibles con la versión anterior, \textbf{X} se incrementa en 1.
	\item \textbf{Y:} La versión menor. Aumenta cuando se agreguen nuevas funcionalidades. Los archivos del usuario (savegames) deben ser siempre compatibles con la versión menor anterior.
	\item \textbf{Z:} La versión de patch. Siempre que se solucionen bugs se incrementa. Cuando avance la versión menor o principal vuelve a cero.
\end{itemize}

Esta nomenclatura se debe aplicar en las ramas \textbf{main} y \textbf{release}.

\subsubsection{Alternativas al modelo de ramas de función}\label{flujo:alternativas-al-branching}
Si el flujo bajo el sistema de ramas de función resulta demasiado tedioso o la visualización general del código se pierde con mucha facilidad ya sea por merges muy complejos o espaciados, se propone como alternativa la metodología de \href{https://es.wikipedia.org/wiki/Entrega_continua}{Entrega continua}.

\subsubsection{Comandos de GIT}\label{flujo:comandos-de-git}
Este apartado es una referencia rápida a los comandos y configuraciones más comunes en el trabajo con \lsc{GIT}.

\begin{itemize}[label=-]
	\item Configuración:
	\begin{lstlisting}
$ ./config/git/config
	\end{lstlisting}
	
	\begin{lstlisting}
conf[user]
name = USUARIO
email = MAIL_REGISTRADO_EN_GITHUB
[credential]
helper = store
[core]
autocrlf = input
	\end{lstlisting}
	
	\item Credentials en archivo $\sim$/.config/git/credentials (asociado al usuario y al repositorio)
	
	\item Archivos y directorios ignorados por \lsc{GIT} (en .gitignore dentro de Bakumapu):
	\begin{lstlisting}
# Godot-specific ignores
.import/
export/
export.cfg
export_presets.cfg

# Mono-specific ignores
.mono/
data_*/
	\end{lstlisting}
	
	\Needspace{7\baselineskip}
	
	\item Evitar problemas de formato de archivo entre Windows (\lsc{CRLF}) y el resto de sistemas:
	\begin{lstlisting}
$ .gitattributes:
	\end{lstlisting}
	\noindent\begin{minipage}{.45\textwidth}
	\begin{lstlisting}
# Set the default behavior, in
# case people
# don't have core.autocrlf set

* text eol=lf

# Explicitly declare text
# files you want to always
# be normalized and converted 
# to native line endings on
# checkout.

*.godot text
*.tscn text
*.gd text
*.tres text
*.import text
*.md text
*.txt text
*.json text
*.xml text
*.py text
*.c text
*.h text

# binary files that should not
# be modified

# fonts
*.ttf binary
*.otf binary
	\end{lstlisting}
	\end{minipage}\hfill
	\begin{minipage}{.45\textwidth}
	\begin{lstlisting}[escapechar=\%]
# images

*.png binary
*.jpg binary
*.jpeg binary
*.webp binary
*.aseprite binary
*.gif binary
*.xcf binary
*.svg binary
*.kra binary

# sound

*.wav binary
*.ogg binary
*.sf2 binary
*.midi binary
*.amr binary
*.musx binary
*.mp3 binary

# misc

*.zip binary
*.rar binary
*.tar.gz



%
	\end{lstlisting}
	\end{minipage}

	\item Clonar el repositorio en el espacio de trabajo local:
	\begin{lstlisting}
$ git clone https://github.com/polirritmico/Bakumapu
	\end{lstlisting}

	\item - Ver el estado de la rama actual:
	\begin{lstlisting}
$ git status
	\end{lstlisting}
	
	\item Cambiar a una rama (por ejemplo develop):
	\begin{lstlisting}
$ git checkout develop
	\end{lstlisting}
	
	\item Crear una nueva rama en base a la rama actual (ejemplo “ft-01”:
	\begin{lstlisting}
$ git checkout -b ft-01
	\end{lstlisting}
	
	\item Enviar la rama local a Github (origin es un alias de la ruta al repo en github):
	\begin{lstlisting}
$ git push -u origin ft-01
	\end{lstlisting}
	
	\item Agrega todos los cambios al área de pruebas:
	\begin{lstlisting}
$ git add .
	\end{lstlisting}
	
	\item Agrega comentarios al commit:
	\begin{lstlisting}
$ git commit -m descripcion
	\end{lstlisting}
	
	\item Envía los cambios locales de la rama actual a Github:
	\begin{lstlisting}
$ git push
	\end{lstlisting}
	
	\item Actualizar el repositorio local desde Github:
	\begin{lstlisting}
$ git pull
	\end{lstlisting}
\end{itemize}

Referencia rápida para comandos \lsc{GIT} \href{https://rogerdudler.github.io/git-guide}{aquí}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Documentación}\label{flujo:documentacion}

\subsubsection{El documento de Diseño técnico}\label{flujo:documento-de-diseno}
A nivel de desarrollo muchas veces terminamos dedicando más tiempo a estudiar el código y a entender su funcionamiento que a escribir nueva funcionalidad, por ello la documentación se vuelve tan relevante. Un código más fácil de entender ahorra tiempo, por eso ayuda a mejorar la estabilidad del software y en general todo el desarrollo se torna más productivo. La documentación técnica de Bakumapu estará dividida en este documento y en los archivos de código (apartado \nameref{flujo:documentacion-en-codigo}).

El presente texto, como ya se ha mencionado, tiene como objetivo desempeñar tres funciones principales:
\begin{enumerate}[noitemsep]
	\item Usarse como referencia ante dudas técnicas o de modelado.
	\item Entregar toda la información relevante acerca del flujo de trabajo y del funcionamiento del software para integrar a nuevos miembros del equipo.
	\item Servir de instrumento de diseño.
\end{enumerate}

Para que estos objetivos se cumplan, el documento debe mantenerse actualizado a medida que se vaya escribiendo el código y tomando las distintas decisiones de diseño e implementación. Por lo mismo se ha generado un repositorio especial para ello (apartado \nameref{flujo:repositorio-de-documentacion}). 

\subsubsection*{¿Qué se documenta aquí?}
No se debe confundir la documentación de este texto con los comentarios o explicaciones dentro del código. El código debe estar debidamente documentado dentro de los archivos y líneas correspondientes (apartado \nameref{flujo:documentacion-en-codigo}). No obstante, cuando haya modificaciones importantes que involucren cambiar o definir la interacción entre clases o elementos de ámbitos más globales, se deberán anotar en este texto a modo de referencia técnica en el apartado \nameref{modelado:funcionamiento-general}.

\paragraph*{Importante:}
Es muy relevante dejar en claro que el objetivo no es escribir una explicación \emph{línea a línea} de cómo funciona el código, sino una \emph{noción general} de ámbitos o lógicas más globales. Con señalar el sentido de estas entidades dentro del sistema y su interacción con el resto será suficiente.

\subsubsection{Modificando el documento}\label{flujo:modificando-el-documento}
Para modificar el documento, basta con utilizar un editor de textos sencillos y seguir la nomenclatura del sistema \LaTeX. En el apartado \nameref{flujo:latex} se proporcionará una breve guía con un listado de los comandos relevantes. En cualquier caso, considerando que el grueso del documento ya está definido, simplemente es cosa de usar los mismos apartados del documento como ejemplo.

Dado que en ciertos contextos la instalación de \LaTeX\ puede ser bastante engorrosa (la instalación manual de muchísimos paquetes), no es necesario compilar una nueva versión con cada cambio sino simplemente mantener los archivos \lsc{TEX} y la versión dentro de \textbf{Makefile} actualizados.

\subsubsection{Versionado del documento}\label{flujo:versionado-del-documento}
Cada modificación a este documento deberá aumentar la numeración de la subversión en 1 (v0.0\textbf{.1} a v0.0\textbf{.2}). Los primeros 2 índices (v\textbf{0.0.}1) estarán en línea con la última rama \textbf{main} del repositorio. Cada vez que se suba una nueva versión de la rama, se deberá chequear que el documento contenga los cambios relevantes a esa versión e incorporarlos. Con cada cambio de versión menor, la subversión debe volver a cero (v0.\textbf{5.36} a v0.\textbf{6.0}). El versionado de las ramas se discutirá más adelante en el apartado \nameref{flujo:versionado-y-nombres}.

Para ajustar la versión del documento solo hay que editar el archivo \textbf{Makefile}, que se encargará automáticamente de hacer todos los ajustes durante la recompilación:
\begin{center}
\texttt{Versión actual: v\docversion.}
\end{center}

\Needspace{3\baselineskip}
\begin{lstlisting}
Bakumapu-docs $ nano Makefile
\end{lstlisting}
\begin{lstlisting}[language=bash]
SHELL = /bin/sh
# Actualizar con cada cambio
VERSION = 0.0.1
\end{lstlisting}

\subsubsection{Exportar a HTML}\label{flujo:exportar-a-html}
Para exportar a \lsc{HTML} bastará con usar el paquete \textbf{make4ht} (utiliza pdflatex y htlatex). Las instrucciones de compilación están configuradas en el fichero Makefile, por lo que la conversión se automatiza con el comando:
\begin{lstlisting}
Bakumapu-docs $ make html
\end{lstlisting}
Esto generará la página \lsc{HTML} con todos los archivos \lsc{CSS}, de fuentes y de imágenes relevantes en la carpeta \textbf{/docs}. Luego restaría simplemente actualizar el repositorio.

\subsubsection{Repositorio de documentación}\label{flujo:repositorio-de-documentacion}
Un simple repositorio \lsc{GIT} en Gitbub, ubicado en: \url{https://github.com/polirritmico/Bakumapu-docs}. Desde aquí solo se puede revisar el código fuente del \lsc{HTML}, para acceder a una versión renderizada está la siguiente \lsc{URL}: \url{https://polirritmico.github.io/Bakumapu-docs/}.

Para sincronizar el servidor además de los comandos \lsc{GIT} habituales, el archivo \textbf{Makefile} tiene las instrucciones para automatizar el proceso:
\begin{lstlisting}
Bakumapu-docs $ make sync
\end{lstlisting}

\subsubsection{Documentación dentro del código}\label{flujo:documentacion-en-codigo}
La búsqueda de simplicidad en el diseño también aplica a la documentación del código. Idealmente éste debe estar “autodocumentado”, es decir que los nombres de las variables, métodos y clases den cuenta de manera transparente e intuitiva su rol dentro de la lógica del algoritmo. En los casos más complejos, es de vital importancia añadir comentarios no solo para facilitar la comprensión de líneas más complejas, sino para ayudar al futuro proceso de refactorización y debbuging. \emph{Los nombres largos no lastran la eficiencia del código}.

En cuanto al formato del código dado que \lsc{GDS}cript está basado en Python, además de las propias sugerencias de Godot se recomienda seguir la \href{https://www.python.org/dev/peps/pep-0008/}{guía de estilo PEP-8}. En especial las siguientes indicaciones:
\begin{itemize}[noitemsep]
	\item Límite horizontal de 79 caracteres. 
	\item Separación de 1 línea en blanco entre funciones y 2 entre clases.
	\item Indentación por 4 espacios.
	\item Operadores y variables separados por un espacio:
	\begin{lstlisting}
var ejemplo = Vector2(2, 5 + PI.get(2))
	\end{lstlisting}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Google Drive}\label{flujo:google-drive}
Se manejará la \href{https://drive.google.com/open?id=1p8u-1UpXts8OHGRHEZLSIiQrqqx0Y4Kt}{carpeta compartida Bakumapu}, cuyo acceso será proporcionado a todos los miembros del desarrollo. En la raíz de esta carpeta se encuentran los documentos principales del diseño del juego, y las siguientes subcarpetas:
\begin{itemize}
	\item \textbf{Herramientas:} Contiene los instaladores, código fuente, o links de descarga del software mencionado en el apartado \nameref{intro:software-y-herramientas} además de los scripts de desarrollo. También contiene tutoriales para los colaboradores no técnicos del proyecto.
	\item \textbf{Referencias:} Libros, imágenes, documentos, audios, videos y todo material referenciado para el desarrollo, inspiración, discusión o diseño del juego.
	\item \textbf{Historia:} Una especie de repositorio para la narrativa del juego. Contiene documentos sobre la historia, biografía de personajes, arcos narrativos, descripciones, locaciones, historia, trasfondos, etc.
	\begin{itemize}
		\item \textbf{Quest y Diálogos.}
		
		Dentro de la carpeta Historia hay dos subdirectorios relevantes a nivel técnico: Quest y Diálogos. Cada uno contendrá planillas con datos que serán importados a Godot programáticamente, es decir se deberá desarrollar un script o programa que transforme su contenido a \lsc{XML}, \lsc{CSV} o \lsc{JSON} y este sea manejable por Godot con \emph{muy poca} intervención.
		
		Más información de estas herramientas en los apartados \nameref{kit:cutscenes-y-dialogos} y \nameref{kit:quests}. Además, estos archivos deberán seguir la convención de nombres detallada en el apartado \nameref{organizacion:nombres-de-archivos}.
	\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{LaTeX}\label{flujo:latex}
Pese a lo que pueda parecer, el uso de \LaTeX\ a nivel básico es bastante sencillo, simplemente es escribir el texto y utilizar comandos para marcar el estilo o contenido para el compilador. En términos prácticos, a nivel básico es escribir el título de una sección, subsección o incluso sub-subsección con el comando correspondiente y separar los párrafos con una línea en blanco entremedio.

En cualquier caso, teniendo los mismos archivos \lsc{TEX} del documento a modo de ejemplo y con la información de este apartado, debiese ser suficiente para todas las modificaciones. Si hubiera por mencionar algo que facilite el proceso, se debería agregar en este apartado.

En lo posible tratar de no agregar nuevos paquetes.

\subsubsection{Lista de comandos LaTeX}\label{flujo:listado-comandos-latex}
Los comandos son palabras claves que el compilador interpreta para generar el documento. Siempre deben comenzar con el signo backslash (\textbackslash).

\noindent A continuación una lista con los comandos más fundamentales:

\begin{enumerate}
\item Comentarios:
\lstset{style=latex}
\begin{lstlisting}
Esto es un texto normal.
% Esto es un comentario. No se compila.
Texto % Comentario.
\end{lstlisting}
\item Escapar símbolos:
\begin{lstlisting}
Necesito escribir una linea \_ y un porcentaje \%
El signo \ funciona con este comando: \textbackslash.
\end{lstlisting}
\item Secciones (en orden descendente):
\begin{lstlisting}
\section{Titulo de seccion}
\subsection{Titulo de subseccion}
\subsection*{Titulo.} % Asterisco para no ennumerar.
\subsubsection{Titulo de subsubseccion}
\paragraph{Titulo de seccion parrafo}
\end{lstlisting}
\item Ajustes tipográficos:
\begin{lstlisting}
Negrita: Texto a \textbf{negrita}.
Enfasis: Texto a \emph{enfasis}
Cursiva: Texto a \textit{cursiva}.
Versalita: Texto a \lsc{versalita}.
\end{lstlisting}

\item Ajustes de párrafo:
	\begin{enumerate}
	\item Alineación:
	\begin{lstlisting}
\begin{centering} % alternativas: flushleft, flushright
Texto alineado en base al valor en begin.
\end{centering}
	\end{lstlisting}
	\Needspace{4\baselineskip}
	\item Saltos de línea:
	\begin{lstlisting}
Los saltos necesitan este comando\\
sino se encadenan en una misma linea.

Los parrafos se separan con una linea en blanco.
	\end{lstlisting}

	\item Quitar sangría:
	\begin{lstlisting}
\noindent Primera linea sin sangria.
	\end{lstlisting}
	\end{enumerate}

\item Referencias:
\begin{lstlisting}
% Lo que queremos referenciar:
\subsection{Titulo subseccion}
% Le agregamos label. Ojala usar {nombre_archivo:descripcion}
\subsection{Titulo subseccion}\label{modelado:titulo-sec}

% Para crear la referencia hacia ese titulo:
La siguiente referencia: \nameref{modelado:titulo-sec}

% Ojo: En label{} solo ASCII basico, no tildes ni enie.
\end{lstlisting}

\item Listas:
\begin{lstlisting}
\begin{enumerate} % Para listas no numeradas usar itemize.
    \item Primer item numerado.
    \item Segundo item numerado.
\end{enumerate}
\end{lstlisting}

\item Imágenes:
\begin{lstlisting}
\begin{figure}[h] % h de here, t top, b bottom o nada.
    \centering
    \includegraphics[]{ruta/al/archivo}
    \caption{Subtitulo.}
    \label{fig:imagen} % Si queremos label para referencia.
\end{figure}
\end{lstlisting}

\Needspace{7\baselineskip}
\item Código:
\begin{lstlisting}
\begin{lstlisting*} % sin el asterisco
% Dentro de lstlisting solo ASCII basico sin tildes ni enies
var test = Clase.llamado(ejemplo.datos, objeto.pos())
$ comando -opciones ruta_a_archivo.txt
\end{lstlisting*} % sin el asterisco
\end{lstlisting}

\item Otros:
\begin{enumerate}
	\item Mover a la siguiente página si no hay espacio disponible:
	\begin{lstlisting}
% el 2\baselineskip es para obtener el alto de 2 lineas
\Needspace{2\baselineskip}
	\end{lstlisting}
	
	\item Salto de página:
	\begin{lstlisting}
\pagebreak
	\end{lstlisting}
	
	\item Espacios indivisible (non-breaking space):
	\begin{lstlisting}
60~hz, 50~km, siglo~\lsc{XVI}.
	\end{lstlisting}
	\lstset{style=bash}
\end{enumerate}

\end{enumerate}